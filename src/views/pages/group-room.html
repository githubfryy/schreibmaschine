<div class="group-room" 
     x-data="groupRoomData()" 
     x-init="initGroupRoom()">
     
  <div class="header">
    <div class="group-info">
      <h1>{{writing_group.name}}</h1>
      <div class="workshop">{{workshop.name}}</div>
    </div>
    <div class="online-status">
      <span x-show="isConnected" class="connection-status online">ğŸŸ¢ Verbunden</span>
      <span x-show="!isConnected" class="connection-status offline">ğŸ”´ Getrennt</span>
      â€¢ <span x-text="onlineCount"></span> Teilnehmer online
    </div>
  </div>
  
  <div class="main">
    <div class="sidebar">
      <h2>ğŸ‘¥ Teilnehmer</h2>
      <ul class="participant-list">
        <template x-for="participant in allParticipants" :key="participant.id">
          <li class="participant" 
              :class="{ 
                'online': isParticipantOnline(participant.id), 
                'offline': !isParticipantOnline(participant.id),
                'teamer': participant.role === 'teamer',
                'current-user': participant.id === currentParticipantId
              }">
            <span x-text="participant.display_name"></span>
            <span x-show="participant.role === 'teamer'"> ğŸ‘‘</span>
            <span x-show="participant.id === currentParticipantId"> (Du)</span>
            <span x-show="isParticipantOnline(participant.id)" class="online-indicator">â—</span>
          </li>
        </template>
      </ul>
      
      <h2>ğŸ¯ AktivitÃ¤ten</h2>
      <div class="activities">
        <template x-for="activity in activities" :key="activity.id">
          <div class="activity-item" 
               :class="activity.status"
               x-on:click="selectActivity(activity.id)">
            <div class="activity-name" x-text="activity.name"></div>
            <div class="activity-status" x-text="getActivityStatusText(activity.status)"></div>
          </div>
        </template>
        
        <div x-show="activities.length === 0" class="no-activities">
          <p>Keine AktivitÃ¤ten verfÃ¼gbar</p>
        </div>
      </div>
      
      <!-- Activity Management (Teamer Only) -->
    <div x-show="isTeamer" class="teamer-controls">
      <h2>ğŸ¯ AktivitÃ¤ten verwalten</h2>
      <div class="teamer-actions">
        <button x-on:click="createActivity()" class="btn btn-primary">
          â• Neue AktivitÃ¤t
        </button>
        <button x-show="currentActivity" x-on:click="toggleActivityStatus()" class="btn btn-secondary">
          <span x-text="currentActivity?.status === 'active' ? 'â¸ï¸ Pausieren' : 'â–¶ï¸ Starten'"></span>
        </button>
      </div>
    </div>
    
    <!-- Logout Button -->
      <div class="logout-section">
        <button x-on:click="logout()" class="logout-btn">
          ğŸšª Abmelden
        </button>
      </div>
    </div>
    
    <div class="content">
      <h2>âœï¸ Schreibraum</h2>
      
      <div x-show="currentActivity" class="activity-area fade-in">
        <div class="activity-header">
          <h3 x-text="currentActivity?.name"></h3>
          <span class="activity-type-badge" :class="currentActivity?.type" x-text="getActivityTypeLabel(currentActivity?.type)"></span>
        </div>
        
        <!-- Individual Writing Pad -->
        <div x-show="currentActivity?.type === 'individual_pad'" class="individual-writing">
          <div class="individual-editor">
            <textarea x-model="individualText" 
                      x-ref="individualTextarea"
                      placeholder="Hier kannst du deine Gedanken und Ideen festhalten..."
                      x-on:input.debounce.500ms="saveIndividualText()"
                      x-on:focus="startWritingSession()"
                      x-on:blur="endWritingSession()"></textarea>
            <div class="writing-stats">
              <div class="word-count">
                <span x-text="wordCount(individualText)"></span> WÃ¶rter
                <span x-show="characterCount(individualText) > 0"> â€¢ <span x-text="characterCount(individualText)"></span> Zeichen</span>
              </div>
              <div class="save-status" :class="saveStatus">
                <span x-show="saveStatus === 'saving'">ğŸ’¾ Speichert...</span>
                <span x-show="saveStatus === 'saved'">âœ… Gespeichert</span>
                <span x-show="saveStatus === 'error'">âŒ Fehler beim Speichern</span>
                <span x-show="lastSaved" class="last-saved">um <span x-text="formatTime(lastSaved)"></span></span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Rhyming Chain Game -->
        <div x-show="currentActivity?.type === 'rhyming_chain'" class="rhyming-game">
          <div x-show="previousLine" class="previous-line">
            <div class="previous-line-label">Vorherige Zeile</div>
            <div x-text="previousLine"></div>
          </div>
          
          <div x-show="isMyTurn" class="turn-status turn-active">
            <h4>ğŸ¯ Du bist am Zug!</h4>
            <p>Schreibe eine Zeile, die sich auf die vorherige reimt.</p>
          </div>
          
          <div x-show="!isMyTurn" class="turn-status turn-waiting">
            <h4>â³ Warten auf <span class="current-player" x-text="currentPlayer"></span></h4>
            <p>Du bist als nÃ¤chstes dran, wenn <span x-text="currentPlayer"></span> fertig ist.</p>
          </div>
          
          <div x-show="isMyTurn" class="rhyme-input-section">
            <input type="text" 
                   class="rhyme-input"
                   x-model="currentRhyme" 
                   x-ref="rhymeInput"
                   placeholder="Deine Zeile hier eingeben..."
                   x-on:keyup.enter="submitRhyme()"
                   maxlength="200">
            <div class="turn-actions">
              <button x-on:click="submitRhyme()" 
                      :disabled="!currentRhyme.trim()"
                      class="btn-submit">
                âœï¸ Zeile senden
              </button>
              <button x-on:click="skipTurn()" class="btn-skip">
                â­ï¸ Zug Ã¼berspringen
              </button>
            </div>
          </div>
        </div>
        
        <!-- Collaborative Writing Pad -->
        <div x-show="currentActivity?.type === 'collaborative_pad'" class="collaborative-writing">
          <div class="collaboration-header">
            <h4>âœï¸ Gemeinsames Schreiben</h4>
            <div class="active-editors">
              <template x-for="editor in activeEditors" :key="editor.id">
                <div class="editor-avatar" :style="{ backgroundColor: editor.color }" :title="editor.name">
                  <span x-text="editor.name.charAt(0).toUpperCase()"></span>
                </div>
              </template>
            </div>
          </div>
          
          <div class="collaborative-editor" 
               x-model="collaborativeText"
               contenteditable="true"
               x-on:input.debounce.300ms="saveCollaborativeText()"
               placeholder="Hier kÃ¶nnen alle gemeinsam schreiben...">
          </div>
          
          <div class="editing-permissions">
            <span x-show="canEdit">Du kannst diesen Text bearbeiten</span>
            <span x-show="!canEdit">Nur Anschauen erlaubt - Teamer kann Bearbeitung freischalten</span>
          </div>
        </div>
      </div>
      
      <div x-show="!currentActivity" class="welcome-message">
        <div class="welcome-icon">âœï¸</div>
        <h3>Willkommen im Schreibraum!</h3>
        <p>WÃ¤hle eine AktivitÃ¤t aus der Seitenleiste aus, um mit dem Schreiben zu beginnen.</p>
        <p x-show="activities.length === 0" class="no-activities-hint">
          <em>Noch keine AktivitÃ¤ten verfÃ¼gbar. Der Teamer wird bald welche erstellen.</em>
        </p>
      </div>
    </div>
  </div>
</div>

<script>
// Alpine.js component for group room functionality
document.addEventListener('alpine:init', () => {
  Alpine.data('groupRoomData', () => ({
    // State
    groupId: '{{workshop_group.id}}',
    currentParticipantId: '{{current_participant.id}}',
    isConnected: false,
    onlineParticipants: [],
    allParticipants: {{{json participants}}},
    activities: {{{json activities}}},
    currentActivity: null,
    
    // Individual writing
    individualText: Alpine.$persist('').as('individual-text-{{current_participant.id}}'),
    lastSaved: null,
    saveStatus: 'saved', // 'saving', 'saved', 'error'
    writingStartTime: null,
    
    // Rhyming game
    isMyTurn: false,
    currentRhyme: '',
    previousLine: '',
    currentPlayer: '',
    
    // Collaborative writing
    collaborativeText: '',
    activeEditors: [],
    canEdit: false,
    
    // Teamer controls
    isTeamer: false
    
    // Computed
    get onlineCount() {
      return this.onlineParticipants.length;
    },
    
    // Initialize group room
    async initGroupRoom() {
      // Check authentication
      const session = await SchreibmaschineAuth.checkSession();
      if (!session.authenticated) {
        window.location.href = '{{urls.lobby_url}}';
        return;
      }
      
      // Start SSE connection (already handled by common.js)
      if (!SchreibmaschineSSE.eventSource) {
        SchreibmaschineSSE.connect(this.groupId);
      }
      
      // Listen for SSE events
      document.addEventListener('sse-event', (event) => {
        this.handleSSEEvent(event.detail);
      });
      
      // Load initial data
      await this.loadActivities();
      await this.checkTeamerStatus();
      
      // Set up keyboard shortcuts
      this.setupKeyboardShortcuts();
      
      // Auto-focus on current activity if available
      if (this.activities.length > 0) {
        const activeActivity = this.activities.find(a => a.status === 'active');
        if (activeActivity) {
          this.selectActivity(activeActivity.id);
        }
      }
    },
    
    // Handle SSE events
    handleSSEEvent(event) {
      switch (event.type) {
        case 'connected':
          this.isConnected = true;
          break;
          
        case 'online_status':
          this.onlineParticipants = event.data.online_participants || [];
          break;
          
        case 'activity_update':
          this.loadActivities();
          break;
          
        case 'heartbeat':
          this.isConnected = true;
          break;
      }
    },
    
    // Check if participant is online
    isParticipantOnline(participantId) {
      return this.onlineParticipants.some(p => p.participant_id === participantId);
    },
    
    // Activity management
    async loadActivities() {
      try {
        const response = await fetch(`/api/groups/${this.groupId}/activities`);
        if (response.ok) {
          const data = await response.json();
          this.activities = data.activities || [];
          
          // Update current activity if it exists
          if (this.currentActivity) {
            const updated = this.activities.find(a => a.id === this.currentActivity.id);
            if (updated) {
              this.currentActivity = updated;
            }
          }
        }
      } catch (error) {
        console.error('Failed to load activities:', error);
      }
    },
    
    async checkTeamerStatus() {
      // Check if current participant is a teamer
      const teamer = this.allParticipants.find(p => 
        p.id === this.currentParticipantId && p.role === 'teamer'
      );
      this.isTeamer = !!teamer;
    },
    
    selectActivity(activityId) {
      const activity = this.activities.find(a => a.id === activityId);
      if (activity) {
        this.currentActivity = activity;
        this.loadActivityState(activityId);
        
        // Focus appropriate input based on activity type
        this.$nextTick(() => {
          if (activity.type === 'individual_pad') {
            const textarea = this.$refs.individualTextarea;
            if (textarea) textarea.focus();
          } else if (activity.type === 'rhyming_chain' && this.isMyTurn) {
            const input = this.$refs.rhymeInput;
            if (input) input.focus();
          }
        });
      }
    },
    
    async loadActivityState(activityId) {
      try {
        const response = await fetch(`/api/activities/${activityId}/state`);
        if (response.ok) {
          const state = await response.json();
          
          if (this.currentActivity?.type === 'rhyming_chain') {
            this.isMyTurn = state.isMyTurn || false;
            this.previousLine = state.previousLine || '';
            this.currentPlayer = state.currentPlayer || '';
          }
        }
      } catch (error) {
        console.error('Failed to load activity state:', error);
      }
    },
    
    // Individual writing
    async saveIndividualText() {
      if (!this.individualText.trim()) {
        this.saveStatus = 'saved';
        return;
      }
      
      this.saveStatus = 'saving';
      
      try {
        const response = await fetch('/api/documents/individual', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            groupId: this.groupId,
            activityId: this.currentActivity?.id,
            content: this.individualText,
            metadata: {
              wordCount: this.wordCount(this.individualText),
              characterCount: this.characterCount(this.individualText),
              writingSession: {
                startTime: this.writingStartTime,
                duration: this.writingStartTime ? Date.now() - this.writingStartTime : 0
              }
            }
          })
        });
        
        if (response.ok) {
          this.lastSaved = new Date();
          this.saveStatus = 'saved';
        } else {
          this.saveStatus = 'error';
        }
      } catch (error) {
        console.error('Failed to save text:', error);
        this.saveStatus = 'error';
      }
    },
    
    startWritingSession() {
      if (!this.writingStartTime) {
        this.writingStartTime = Date.now();
      }
    },
    
    endWritingSession() {
      // Session tracking for analytics (could be extended)
    },
    
    // Rhyming game
    async submitRhyme() {
      if (!this.currentRhyme.trim()) return;
      
      try {
        const response = await fetch(`/api/activities/${this.currentActivity.id}/submit`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            content: this.currentRhyme
          })
        });
        
        if (response.ok) {
          this.currentRhyme = '';
          this.loadActivityState(this.currentActivity.id);
        }
      } catch (error) {
        console.error('Failed to submit rhyme:', error);
      }
    },
    
    async skipTurn() {
      if (!confirm('MÃ¶chtest du wirklich deinen Zug Ã¼berspringen?')) return;
      
      try {
        const response = await fetch(`/api/activities/${this.currentActivity.id}/skip`, {
          method: 'POST'
        });
        
        if (response.ok) {
          this.loadActivityState(this.currentActivity.id);
        }
      } catch (error) {
        console.error('Failed to skip turn:', error);
      }
    },
    
    // Text utilities
    wordCount(text) {
      return text.trim() ? text.trim().split(/\s+/).length : 0;
    },
    
    characterCount(text) {
      return text.length;
    },
    
    formatTime(date) {
      return date ? date.toLocaleTimeString('de-DE') : '';
    },
    
    getActivityStatusText(status) {
      const statusMap = {
        'setup': 'Vorbereitung',
        'active': 'Aktiv',
        'paused': 'Pausiert',
        'completed': 'Abgeschlossen'
      };
      return statusMap[status] || status;
    },
    
    getActivityTypeLabel(type) {
      const typeMap = {
        'individual_pad': 'Einzelarbeit',
        'collaborative_pad': 'Gemeinsam',
        'rhyming_chain': 'Reimkette',
        'paper_drawing': 'Zeichnung',
        'timed_writing': 'Zeitschreiben'
      };
      return typeMap[type] || type;
    },
    
    // Teamer controls
    async createActivity() {
      // This would open a modal or navigate to activity creation
      // For now, just placeholder
      alert('AktivitÃ¤t erstellen - In Entwicklung');
    },
    
    async toggleActivityStatus() {
      if (!this.currentActivity) return;
      
      const newStatus = this.currentActivity.status === 'active' ? 'paused' : 'active';
      
      try {
        const response = await fetch(`/api/activities/${this.currentActivity.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status: newStatus })
        });
        
        if (response.ok) {
          await this.loadActivities();
        }
      } catch (error) {
        console.error('Failed to toggle activity status:', error);
      }
    },
    
    // Collaborative writing
    async saveCollaborativeText() {
      // Placeholder for collaborative text saving
      console.log('Saving collaborative text:', this.collaborativeText);
    },
    
    // Logout
    async logout() {
      if (confirm('MÃ¶chtest du dich wirklich abmelden?')) {
        await SchreibmaschineAuth.logout();
      }
    },
    
    // Keyboard shortcuts
    setupKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        // Global shortcuts
        if (e.ctrlKey && e.shiftKey && e.key === 'L') {
          e.preventDefault();
          this.logout();
        }
        
        // Activity-specific shortcuts
        if (this.currentActivity) {
          if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            if (this.currentActivity.type === 'individual_pad') {
              this.saveIndividualText();
            }
          }
          
          if (this.currentActivity.type === 'rhyming_chain' && this.isMyTurn) {
            if (e.key === 'Enter' && e.ctrlKey) {
              e.preventDefault();
              this.submitRhyme();
            }
            if (e.key === 'Escape') {
              e.preventDefault();
              this.skipTurn();
            }
          }
        }
      });
    }
  }));
});
</script>