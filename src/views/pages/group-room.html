<div class="group-room" 
     x-data="groupRoomData()" 
     x-init="initGroupRoom()">
     
  <div class="header">
    <div class="group-info">
      <h1>{{writing_group.name}}</h1>
      <div class="workshop">{{workshop.name}}</div>
    </div>
    <div class="online-status">
      <span x-show="isConnected" class="connection-status online">üü¢ Verbunden</span>
      <span x-show="!isConnected" class="connection-status offline">üî¥ Getrennt</span>
      ‚Ä¢ <span x-text="onlineCount"></span> Teilnehmer online
    </div>
  </div>
  
  <div class="main">
    <div class="sidebar">
      <h2>üë• Teilnehmer</h2>
      <ul class="participant-list">
        <template x-for="participant in allParticipants" :key="participant.id">
          <li class="participant" 
              :class="{ 
                'online': isParticipantOnline(participant.id), 
                'offline': !isParticipantOnline(participant.id),
                'teamer': participant.role === 'teamer',
                'current-user': participant.id === currentParticipantId
              }">
            <span x-text="participant.display_name"></span>
            <span x-show="participant.role === 'teamer'"> üëë</span>
            <span x-show="participant.id === currentParticipantId"> (Du)</span>
            <span x-show="isParticipantOnline(participant.id)" class="online-indicator">‚óè</span>
          </li>
        </template>
      </ul>
      
      <h2>üéØ Aktivit√§ten</h2>
      <div class="activities">
        <template x-for="activity in activities" :key="activity.id">
          <div class="activity-item" 
               :class="activity.status"
               x-on:click="selectActivity(activity.id)">
            <div class="activity-name" x-text="activity.name"></div>
            <div class="activity-status" x-text="getActivityStatusText(activity.status)"></div>
          </div>
        </template>
        
        <div x-show="activities.length === 0" class="no-activities">
          <p>Keine Aktivit√§ten verf√ºgbar</p>
        </div>
      </div>
      
      <!-- Logout Button -->
      <div class="logout-section">
        <button x-on:click="logout()" class="logout-btn">
          üö™ Abmelden
        </button>
      </div>
    </div>
    
    <div class="content">
      <h2>‚úçÔ∏è Schreibraum</h2>
      
      <div x-show="currentActivity" class="activity-area">
        <h3 x-text="currentActivity?.name"></h3>
        <div x-show="currentActivity?.type === 'individual_pad'" class="individual-writing">
          <textarea x-model="individualText" 
                    placeholder="Hier kannst du schreiben..."
                    rows="15"
                    x-on:input.debounce.500ms="saveIndividualText()"></textarea>
          <div class="writing-stats">
            <span x-text="wordCount(individualText)"></span> W√∂rter ‚Ä¢ 
            <span x-show="lastSaved">Zuletzt gespeichert: <span x-text="formatTime(lastSaved)"></span></span>
          </div>
        </div>
        
        <div x-show="currentActivity?.type === 'rhyming_chain'" class="rhyming-game">
          <div x-show="isMyTurn" class="turn-active">
            <p><strong>Du bist dran!</strong></p>
            <p>Letzte Zeile: "<em x-text="previousLine"></em>"</p>
            <input type="text" 
                   x-model="currentRhyme" 
                   placeholder="Schreibe eine passende Zeile..."
                   x-on:keyup.enter="submitRhyme()">
            <div class="turn-actions">
              <button x-on:click="submitRhyme()" :disabled="!currentRhyme.trim()">
                ‚úçÔ∏è Zeile senden
              </button>
              <button x-on:click="skipTurn()" class="skip-btn">
                ‚è≠Ô∏è √úberspringen
              </button>
            </div>
          </div>
          
          <div x-show="!isMyTurn" class="turn-waiting">
            <p><span x-text="currentPlayer"></span> ist dran...</p>
            <p>Warte auf die n√§chste Runde.</p>
          </div>
        </div>
      </div>
      
      <div x-show="!currentActivity" class="welcome-message">
        <p>Willkommen in der Schreibgruppe! Die Aktivit√§ten werden hier angezeigt, sobald sie vom Teamer gestartet werden.</p>
      </div>
    </div>
  </div>
</div>

<script>
// Alpine.js component for group room functionality
document.addEventListener('alpine:init', () => {
  Alpine.data('groupRoomData', () => ({
    // State
    groupId: '{{workshop_group.id}}',
    currentParticipantId: '{{current_participant.id}}',
    isConnected: false,
    onlineParticipants: [],
    allParticipants: {{{json participants}}},
    activities: {{{json activities}}},
    currentActivity: null,
    
    // Individual writing
    individualText: Alpine.$persist('').as('individual-text-{{current_participant.id}}'),
    lastSaved: null,
    
    // Rhyming game
    isMyTurn: false,
    currentRhyme: '',
    previousLine: '',
    currentPlayer: '',
    
    // Computed
    get onlineCount() {
      return this.onlineParticipants.length;
    },
    
    // Initialize group room
    async initGroupRoom() {
      // Check authentication
      const session = await SchreibmaschineAuth.checkSession();
      if (!session.authenticated) {
        window.location.href = '{{urls.lobby_url}}';
        return;
      }
      
      // Start SSE connection (already handled by common.js)
      if (!SchreibmaschineSSE.eventSource) {
        SchreibmaschineSSE.connect(this.groupId);
      }
      
      // Listen for SSE events
      document.addEventListener('sse-event', (event) => {
        this.handleSSEEvent(event.detail);
      });
      
      // Load initial data
      this.loadActivities();
      
      // Set up keyboard shortcuts
      this.setupKeyboardShortcuts();
    },
    
    // Handle SSE events
    handleSSEEvent(event) {
      switch (event.type) {
        case 'connected':
          this.isConnected = true;
          break;
          
        case 'online_status':
          this.onlineParticipants = event.data.online_participants || [];
          break;
          
        case 'activity_update':
          this.loadActivities();
          break;
          
        case 'heartbeat':
          this.isConnected = true;
          break;
      }
    },
    
    // Check if participant is online
    isParticipantOnline(participantId) {
      return this.onlineParticipants.some(p => p.participant_id === participantId);
    },
    
    // Activity management
    async loadActivities() {
      try {
        const response = await fetch(`/api/groups/${this.groupId}/activities`);
        if (response.ok) {
          const data = await response.json();
          this.activities = data.activities || [];
        }
      } catch (error) {
        console.error('Failed to load activities:', error);
      }
    },
    
    selectActivity(activityId) {
      const activity = this.activities.find(a => a.id === activityId);
      if (activity && activity.status === 'active') {
        this.currentActivity = activity;
        this.loadActivityState(activityId);
      }
    },
    
    async loadActivityState(activityId) {
      try {
        const response = await fetch(`/api/activities/${activityId}/state`);
        if (response.ok) {
          const state = await response.json();
          
          if (this.currentActivity?.type === 'rhyming_chain') {
            this.isMyTurn = state.isMyTurn || false;
            this.previousLine = state.previousLine || '';
            this.currentPlayer = state.currentPlayer || '';
          }
        }
      } catch (error) {
        console.error('Failed to load activity state:', error);
      }
    },
    
    // Individual writing
    async saveIndividualText() {
      if (!this.individualText.trim()) return;
      
      try {
        const response = await fetch('/api/documents/individual', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            groupId: this.groupId,
            content: this.individualText
          })
        });
        
        if (response.ok) {
          this.lastSaved = new Date();
        }
      } catch (error) {
        console.error('Failed to save text:', error);
      }
    },
    
    // Rhyming game
    async submitRhyme() {
      if (!this.currentRhyme.trim()) return;
      
      try {
        const response = await fetch(`/api/activities/${this.currentActivity.id}/submit`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            content: this.currentRhyme
          })
        });
        
        if (response.ok) {
          this.currentRhyme = '';
          this.loadActivityState(this.currentActivity.id);
        }
      } catch (error) {
        console.error('Failed to submit rhyme:', error);
      }
    },
    
    async skipTurn() {
      if (!confirm('M√∂chtest du wirklich deinen Zug √ºberspringen?')) return;
      
      try {
        const response = await fetch(`/api/activities/${this.currentActivity.id}/skip`, {
          method: 'POST'
        });
        
        if (response.ok) {
          this.loadActivityState(this.currentActivity.id);
        }
      } catch (error) {
        console.error('Failed to skip turn:', error);
      }
    },
    
    // Utilities
    wordCount(text) {
      return text.trim() ? text.trim().split(/\s+/).length : 0;
    },
    
    formatTime(date) {
      return date ? date.toLocaleTimeString('de-DE') : '';
    },
    
    getActivityStatusText(status) {
      const statusMap = {
        'setup': 'Vorbereitung',
        'active': 'Aktiv',
        'paused': 'Pausiert',
        'completed': 'Abgeschlossen'
      };
      return statusMap[status] || status;
    },
    
    // Logout
    async logout() {
      if (confirm('M√∂chtest du dich wirklich abmelden?')) {
        await SchreibmaschineAuth.logout();
      }
    },
    
    // Keyboard shortcuts
    setupKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === 'L') {
          e.preventDefault();
          this.logout();
        }
      });
    }
  }));
});
</script>